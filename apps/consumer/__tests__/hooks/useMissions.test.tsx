import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor, act } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useMissions, useAddMission, type Mission } from '../../src/hooks/useMissions';
import { AuthProvider } from '../../src/contexts/AuthContext';
import { StoreProvider } from '../../src/contexts/StoreContext';
import type { ReactNode } from 'react';

// Mock wallet for tests
const TEST_WALLET = {
  address: '0x1234567890abcdef1234567890abcdef12345678',
  publicKey: 'test-public-key',
};

// Sample test missions for seeding (Sprint 11a: no auto-seeding, tests must seed manually)
const SAMPLE_MISSIONS: Omit<Mission, 'id' | 'createdAt'>[] = [
  {
    type: 'shopping',
    title: 'Test Product',
    description: 'A great product for you',
    price: 99.99,
    priority: 1,
  },
  {
    type: 'savings',
    title: 'Save on Energy',
    description: 'Switch providers to save',
    savings: 200,
    priority: 2,
  },
  {
    type: 'travel',
    title: 'Weekend Getaway',
    description: 'Relax and recharge',
    price: 500,
    priority: 3,
  },
  {
    type: 'health',
    title: 'Wellness Check',
    description: 'Schedule your annual checkup',
    priority: 4,
  },
  {
    type: 'content',
    title: 'Learn Photography',
    description: 'Based on your interests',
    priority: 5,
  },
];

// Create fresh query client for each test
const createQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
  },
});

let queryClient: QueryClient;

/**
 * Test wrapper that provides all required contexts
 * Uses forceInMemory to avoid IndexedDB in tests
 */
const createWrapper = () => {
  const Wrapper = ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <StoreProvider forceInMemory>
          {children}
        </StoreProvider>
      </AuthProvider>
    </QueryClientProvider>
  );
  return Wrapper;
};

describe('useMissions hook', () => {
  beforeEach(() => {
    queryClient = createQueryClient();
    // Set up authenticated state before each test
    localStorage.setItem('ownyou_wallet', JSON.stringify(TEST_WALLET));
  });

  afterEach(() => {
    queryClient.clear();
    localStorage.removeItem('ownyou_wallet');
  });

  it('returns initial loading state', () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    // Initially loading because store needs to be ready
    expect(result.current.isLoading).toBe(true);
    expect(result.current.missions).toEqual([]);
  });

  it('returns isStoreReady flag', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    // isStoreReady reflects store context state
    expect(typeof result.current.isStoreReady).toBe('boolean');

    // Wait for store to be ready
    await waitFor(() => {
      expect(result.current.isStoreReady).toBe(true);
    }, { timeout: 3000 });
  });

  it('returns empty array for new users (Sprint 11a: no auto-seeding)', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    // Wait for store to be ready
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // Sprint 11a: No auto-seeding - new users see empty state
    // Missions are ONLY generated by agents through TriggerContext
    expect(result.current.missions).toEqual([]);
    expect(result.current.hasMissions).toBe(false);
  });

  it('returns hasMissions flag correctly', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // No missions for new user = hasMissions is false
    expect(result.current.hasMissions).toBe(false);
  });

  it('filters missions by savings filter', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('savings'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // If there are savings missions, they should be correctly filtered
    result.current.missions.forEach(mission => {
      expect(['savings', 'shopping']).toContain(mission.type);
    });
  });

  it('filters missions by ikigai filter', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('ikigai'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // If there are ikigai missions, they should be correctly filtered
    result.current.missions.forEach(mission => {
      expect(['content', 'travel', 'entertainment', 'food', 'people']).toContain(mission.type);
    });
  });

  it('filters missions by health filter', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('health'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // If there are health missions, they should be correctly filtered
    result.current.missions.forEach(mission => {
      expect(mission.type).toBe('health');
    });
  });

  it('returns refetch function', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    expect(typeof result.current.refetch).toBe('function');
  });

  it('returns null error when no error', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    expect(result.current.error).toBeNull();
  });
});

describe('useAddMission hook', () => {
  beforeEach(() => {
    queryClient = createQueryClient();
    localStorage.setItem('ownyou_wallet', JSON.stringify(TEST_WALLET));
  });

  afterEach(() => {
    queryClient.clear();
    localStorage.removeItem('ownyou_wallet');
  });

  it('returns addMission function', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useAddMission(), { wrapper });

    await waitFor(() => {
      expect(result.current.isReady).toBe(true);
    }, { timeout: 3000 });

    expect(typeof result.current.addMission).toBe('function');
  });

  it('returns isReady flag', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useAddMission(), { wrapper });

    expect(typeof result.current.isReady).toBe('boolean');

    await waitFor(() => {
      expect(result.current.isReady).toBe(true);
    }, { timeout: 3000 });
  });

  it('can add a mission to store', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useAddMission(), { wrapper });

    await waitFor(() => {
      expect(result.current.isReady).toBe(true);
    }, { timeout: 3000 });

    let addedMission: Mission | undefined;
    await act(async () => {
      addedMission = await result.current.addMission(SAMPLE_MISSIONS[0]);
    });

    // Verify mission was created with id and createdAt
    expect(addedMission).toBeDefined();
    expect(addedMission!.id).toBeDefined();
    expect(addedMission!.createdAt).toBeInstanceOf(Date);
    expect(addedMission!.type).toBe('shopping');
    expect(addedMission!.title).toBe('Test Product');
  });
});

describe('useMissions store integration', () => {
  beforeEach(() => {
    queryClient = createQueryClient();
    localStorage.setItem('ownyou_wallet', JSON.stringify(TEST_WALLET));
  });

  afterEach(() => {
    queryClient.clear();
    localStorage.removeItem('ownyou_wallet');
  });

  it('integrates with store context for isReady', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    // Wait for store to be ready
    await waitFor(() => {
      expect(result.current.isStoreReady).toBe(true);
    }, { timeout: 3000 });

    // Loading should complete once store is ready
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 3000 });
  });

  it('provides refetch function for manual refresh', async () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useMissions('all'), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    }, { timeout: 5000 });

    // Refetch should be available
    expect(typeof result.current.refetch).toBe('function');
    expect(typeof result.current.refreshMissions).toBe('function');
  });
});
