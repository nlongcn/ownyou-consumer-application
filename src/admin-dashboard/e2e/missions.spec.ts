import { test, expect } from '@playwright/test';

/**
 * Missions Page E2E Tests - Sprint 3
 *
 * Tests the Mission Cards UI from v13 Section 3.4:
 * - Mission feed display and filtering
 * - Mission action handling (navigate, external, confirm)
 * - Feedback collection (love/like/meh)
 * - Episode stats display
 *
 * Sprint 4 Extension: Learning loop integration tests
 */

test.describe('Missions Page', () => {
  test.beforeEach(async ({ page }) => {
    // Navigate to missions page
    await page.goto('/missions');
  });

  test.describe('Page Structure', () => {
    test('should display page header', async ({ page }) => {
      await expect(page.getByRole('heading', { name: 'Mission Cards' })).toBeVisible();
      await expect(page.getByText('Personalized missions generated by your AI agents')).toBeVisible();
    });

    test('should show loading state or content', async ({ page }) => {
      // The page should show either loading state OR content (if already loaded)
      // This tests that the page renders something meaningful
      const loadingText = page.getByText('Loading missions...');
      const emptyMessage = page.getByText('No missions yet');
      const missionFeed = page.getByRole('tablist', { name: 'Mission filters' });

      // At least one of these should be visible
      const hasContent =
        (await loadingText.isVisible().catch(() => false)) ||
        (await emptyMessage.isVisible().catch(() => false)) ||
        (await missionFeed.isVisible().catch(() => false));

      expect(hasContent).toBeTruthy();
    });

    test('should display empty state or content after store initializes', async ({ page }) => {
      // Wait for page to finish initial render
      await page.waitForLoadState('domcontentloaded');

      // The filter tabs should be visible regardless of loading state
      await expect(page.getByRole('tablist', { name: 'Mission filters' })).toBeVisible();

      // Either loading, empty state, or missions should be shown
      // We don't force the loading to complete as IndexedDB may be slow in test env
    });

    test('should show Agent Learning Stats when episodes exist', async ({ page }) => {
      // This test is conditional - stats only appear after store loads with episodes
      // We test the structure exists, not that it necessarily loads in test environment
      await page.waitForLoadState('domcontentloaded');

      // The help section should always be visible (doesn't depend on data loading)
      await expect(page.getByRole('heading', { name: 'How Missions Work' })).toBeVisible();

      // Stats section visibility depends on data - just verify page structure is correct
      // The section will appear if episodic memory has entries after loading completes
    });

    test('should display How Missions Work help section', async ({ page }) => {
      await expect(page.getByRole('heading', { name: 'How Missions Work' })).toBeVisible();
      await expect(page.getByText('Shopping Agent:')).toBeVisible();
      await expect(page.getByText('Feedback Loop:')).toBeVisible();
      await expect(page.getByText('Episodes:')).toBeVisible();
      await expect(page.getByText('Privacy:')).toBeVisible();
    });

    test('should display Related Pages navigation', async ({ page }) => {
      await expect(page.getByRole('heading', { name: 'Related Pages' })).toBeVisible();

      // Links have compound accessible names including the icon text
      await expect(page.getByRole('link', { name: /Email.*Classification/i })).toBeVisible();
      await expect(page.getByRole('link', { name: /Profile.*IAB Profile/i })).toBeVisible();
      await expect(page.getByRole('link', { name: /Evidence.*Reasoning/i })).toBeVisible();
    });
  });

  test.describe('Filter Tabs', () => {
    test('should display filter tabs', async ({ page }) => {
      // Wait for page to load
      await page.waitForLoadState('domcontentloaded');

      // Filter tabs are actual tab elements in a tablist
      const tablist = page.getByRole('tablist', { name: 'Mission filters' });
      await expect(tablist).toBeVisible();

      // Check individual tabs
      await expect(page.getByRole('tab', { name: 'All' })).toBeVisible();
      await expect(page.getByRole('tab', { name: 'Active' })).toBeVisible();
      await expect(page.getByRole('tab', { name: 'Snoozed' })).toBeVisible();
      await expect(page.getByRole('tab', { name: 'Completed' })).toBeVisible();
      await expect(page.getByRole('tab', { name: 'Dismissed' })).toBeVisible();
    });

    test('should allow clicking on filter tabs', async ({ page }) => {
      await page.waitForLoadState('domcontentloaded');

      // Click on Active tab
      const activeTab = page.getByRole('tab', { name: 'Active' });
      await activeTab.click();

      // Verify the tab was clicked (page doesn't crash, tab is still visible)
      await expect(activeTab).toBeVisible();

      // URL should still be on missions page
      await expect(page).toHaveURL(/.*missions.*/);

      // Click back to All tab
      const allTab = page.getByRole('tab', { name: 'All' });
      await allTab.click();
      await expect(allTab).toBeVisible();
    });
  });

  test.describe('Navigation', () => {
    test('should navigate to Email Classification page', async ({ page }) => {
      // Use the link with compound accessible name
      const emailLink = page.getByRole('link', { name: /Email.*Classification/i });
      await emailLink.click();
      await expect(page).toHaveURL('/emails');
    });

    test('should navigate to IAB Profile page', async ({ page }) => {
      // Use the link with compound accessible name
      const profileLink = page.getByRole('link', { name: /Profile.*IAB Profile/i });
      await profileLink.click();
      await expect(page).toHaveURL('/profile');
    });

    test('should navigate to Evidence page', async ({ page }) => {
      // Use the link with compound accessible name
      const evidenceLink = page.getByRole('link', { name: /Evidence.*Reasoning/i });
      await evidenceLink.click();
      await expect(page).toHaveURL('/evidence');
    });
  });

  test.describe('Error Handling', () => {
    test('should handle page load gracefully even with store issues', async ({ page }) => {
      // This test verifies the page doesn't crash completely
      // The actual error handling may vary based on implementation
      await page.goto('/missions');

      // Page should at least show the header structure
      await expect(page.getByRole('heading', { name: 'Mission Cards' })).toBeVisible();

      // And the help section which doesn't depend on store
      await expect(page.getByRole('heading', { name: 'How Missions Work' })).toBeVisible();
    });
  });
});

test.describe('Missions Page with Data', () => {
  test.beforeEach(async ({ page }) => {
    // Seed IndexedDB with test data before navigating
    await page.addInitScript(() => {
      // This will be executed before the page loads
      const seedData = async () => {
        const request = indexedDB.open('ownyou_store', 1);

        request.onupgradeneeded = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;

          // Create mission_cards object store
          if (!db.objectStoreNames.contains('mission_cards')) {
            db.createObjectStore('mission_cards', { keyPath: 'key' });
          }

          // Create episodic_memory object store
          if (!db.objectStoreNames.contains('episodic_memory')) {
            db.createObjectStore('episodic_memory', { keyPath: 'key' });
          }
        };

        request.onsuccess = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;

          // Add test mission
          const tx = db.transaction(['mission_cards'], 'readwrite');
          const store = tx.objectStore('mission_cards');

          const testMission = {
            key: 'default_user:mission_cards:test-mission-1',
            value: {
              id: 'test-mission-1',
              title: 'Test Shopping Mission',
              description: 'Found great deals on electronics you were looking for',
              status: 'CREATED',
              priority: 'high',
              triggerAgentId: 'shopping-agent',
              createdAt: new Date().toISOString(),
              actions: [
                {
                  type: 'navigate',
                  label: 'View Deals',
                  payload: { route: '/deals' },
                },
              ],
            },
          };

          store.put(testMission);
        };
      };

      seedData();
    });

    await page.goto('/missions');
    await page.waitForLoadState('networkidle');
  });

  test('should display mission cards when data exists', async ({ page }) => {
    // Look for mission content
    const missionTitle = page.getByText('Test Shopping Mission');
    if (await missionTitle.isVisible({ timeout: 5000 })) {
      await expect(missionTitle).toBeVisible();
    }
  });

  test('should show mission action buttons', async ({ page }) => {
    const viewDealsButton = page.getByRole('button', { name: /View Deals/i });
    if (await viewDealsButton.isVisible({ timeout: 5000 })) {
      await expect(viewDealsButton).toBeVisible();
    }
  });
});

/**
 * Sprint 4 Extension Tests - Learning Loop Integration
 *
 * These tests will be implemented when Sprint 4 Memory Architecture is complete.
 * They test the full learning loop from feedback to procedural rule synthesis.
 */
test.describe.skip('Sprint 4: Learning Loop Integration', () => {
  test('should record feedback and create episode', async ({ page }) => {
    // TODO: Sprint 4 - Test that clicking love/like/meh:
    // 1. Updates mission with userRating
    // 2. Creates/updates linked episode
    // 3. Stores in episodic memory namespace
  });

  test('should trigger Reflection Node on sufficient episodes', async ({ page }) => {
    // TODO: Sprint 4 - Test that:
    // 1. After 10+ episodes, Reflection Node runs
    // 2. Procedural rules are synthesized
    // 3. Rules are stored in procedural memory namespace
  });

  test('should inject memory context into agent prompts', async ({ page }) => {
    // TODO: Sprint 4 - Test that:
    // 1. Semantic memories are retrieved for agent context
    // 2. Similar episodes are found and included
    // 3. Procedural rules are applied to agent behavior
  });

  test('should update agent behavior based on feedback patterns', async ({ page }) => {
    // TODO: Sprint 4 - Test that:
    // 1. Negative feedback on category reduces future suggestions
    // 2. Positive feedback increases similar suggestions
    // 3. Mission quality improves over time
  });
});
